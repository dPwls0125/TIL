
- 운영체제 쓰레드
    - 쓰레드 라이프 사이클
    - 스케줄링
    - 생성 소멸 
- 운영체제 쓰레드와 java의 쓰레드 객체와의 관계 
```
Java Thread는 '스레드'가 아니라 Os 쓰레드를 가리키는 JVM의 핸들이다. 

Java Thread 객체
   └ JVM 내부 구조체
      └ OS Thread (진짜 실행 주체)
         └ CPU에서 실행됨
```

## 프로세스 
메모리에 적재하여 실행중인 프로세스

**PCB(프로세스 제어 블록)**

타이머 인터럽트가 발생하면, CPU를 사용하던 프로세스는 차례를 양보하고 기다려야한다.
PCB는 프로세스 생성 시에 만들어지고, 실행이 끝나면 폐기 된다. (프로세스가 생성되었다. == 운영체제가 PCB를 생성했다.)

- 프로세스 ID (pid)
- 레지스터 값
- 프로세스 상태 
- CPU 스케줄링 정보 
- 메모리 관리 정보 
- 사용한 파일과 입출력장치 목록 
- PPID

위의 정보들이 PCB에 저장되는 내용들이다. 위의 내용들은 인터럽트가 발생했을떄 실행의 상황을 담아두는 하나의 **문맥** 이라고 볼 수 있다. => 프로세스 간에 실행을 전환하는 것을 "문맥 교환"이라고 부른다. 

PCB는 메모리의 **커널 영역**에 저장된다. 사용자영역의 동적 공간, 정적 공간에 나누어 프로세스 데이터들이 저장된다.



**프로세스 상태**

- 생성 상태(new)  
이제 막 메모리에 적재 되어 **PCB를 할당 받은** 상태.

- 준비 상태(ready)  
CPU를 할당받아 실행할 수 있지만, 아직 자신의 차례를 기다리고 있는 상태. 

- 실행 상태(running)  
CPU를 할당 받아 실행 중인 상태. **타이머 인터럽트**가 발생하면 다시 **준비 상태**가 되고, 실행 도중 **입출력장치를 사용**하여 입출력 장치의 작업이 끝날 때까지 기다려야 한다면 **대기 상태**가 된다. 

- 대기 상태(waiting)  
입출력 장치의 작업을 기다리는 상태 

- 종료 상태(terminated)  
프로세스가 종료된 상태. 프로세스가 종료되면 운영체제는 **PCB와 프로세스가 사용한 메모리를 정리**한다. 


**프로세스 생성 기법**

예시 : bash 셸에서 ls 명령을 실행한다고 할 때, 어떻게 실행될까? 

위의 예시에서 프로세스가 생성되는 방식을 알기 위해서는 **fork와 exec** 시스템 콜에 대해 알아야한다. 


- Fork  
부모 프로세스는 fork를 통해 자신의 복사본을 자식 프로세스로 생성해냄 

- Exec  
복제된 프로세스(자식 프로세스)는 해당 공간을 다른 프로그램으로 바꾸어 실행함. 


==> 즉 위의 예시에서 bash 프로그램은 자기 복제를 통해 자식 프로세스를 만들고 해당 공간을 exec을 하여 ls 프로그램이 메모리에 채워지도록 대체한다. 