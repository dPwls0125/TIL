# Thread 

자바가 OS(플랫폼) 독립적이라고는 하지만, 실제로는 OS종속적인 부분이 몇 가지 있는데 쓰레드도 그 중의 하나이다. 

**실행중인 프로세스가 OS의 프로세스 스케줄러의 영항을 받는다.** JVM의 쓰레드 스케줄러에 의해서 어떤 쓰레드가 얼마동안 실행될 것이지 결정되는 것과 같이 프로세스도 프로세스 스케줄러에 의해서 실행 순서와 실행 시간이 결정되기 떄문에 매 순간 상황에 따라 프로세스에게 할당되는 실행시간이 일정하지 않고 쓰레드에게 할당되는 시간 역시 일정하지 않게 된다. 그래서 쓰레드가 이러한 불확실성을 가지고 있다는 것을 염두해 두어야 한다.


위의 논리에 따라, GC stop the world릃 할 필요가 있나? 그냥 Application Thread에 대해 자원을 할당하지 않으면 되는거 아닌가?라는 멘토님의 질문은 틀린 것이 맞다는 것을 확인 할 수 있다. 

JVM 스케줄러가 아무리 java thread에 우선순위를 부여한다고 해서, 실질적인 OS의 프로세스 스케줄링에 직접적으로 관여할 수 없다. 따라서 JVM 스케줄링 방식이 일관된다고 해서 OS 마다 동일한 방식으로 Thread가 싫행되지 않을 있다. 


정리하자면 

## 1. "Java Thread는 OS 스케줄링의 영향을 받는다."

자바가 플랫폼 독립적이지만, 쓰레드는 OS 종속적인 부분이다. 

현대 JVM은 대부분 Java Thread = OS native Thread(1:1) 매핑 구조이기 때문에, 
- JVM은 "어떤 쓰레드를 실행하고 싶다."는 의도만 가질 수 있고
- 실제 CPU를 언제 주는지는 OS 스케줄러가 결정합니다. 

따라서 JVM 스레드 스케줄링 정책이 동일하더라도,

- JVM 스레드 스케줄링 정책이 동일하더라도 
- OS, 커널 버전, 시스템 부하에 따라 실제 실행 결과는 달라질 후 있다. 


# "GC에서 그냥 Application Thread에 자원을 안 주면 되지 않나?"에 대한 반박

- STW는 OS가 Thread를 멈추는 것이 아니라, 
- JVM이 Safepoint라는 '멈춰도 안전한 지점'을 만들어 
- Application Thread가 스스로 멈추게 하는 협조적 메커니즘이다. 



---

### AI 정리 

**Safepoint란?**  
 "이 지점에서 멈추면, JVM이 모든 Thread의 스택/레지스터/힙 참조 상태를 정확히 알 수 있는 지점."  


 **Stop-The-World(STW)가 반드시 필요한 이유 (핵심 논리)**

GC 입장에서 보면 질문은 이렇게 바뀝니다.

“Application Thread가 힙을 수정하는 동안,
내가 객체 생존 여부를 정확히 판단할 수 있는가?”

정답은 ❌ 불가능입니다.

예시

GC가 어떤 객체 A를 “더 이상 참조 없음”이라고 판단하는 순간

다른 Application Thread가 그 객체를 다시 참조하면?

→ 메모리 안정성 붕괴 (Use-after-free)

그래서 GC는 반드시 다음 상태를 만들어야 합니다.

모든 Application Thread가 힙을 전혀 건드리지 않는 상태

이 상태를 보장하는 가장 확실한 방법이 바로
👉 Stop-The-World


** “CPU를 안 주면 멈춘 것 아닌가?”가 성립하지 않는 이유**

OS 스케줄러는 언제든지 Thread를 다시 실행할 수 있음

JVM은 “이 쓰레드는 지금 실행하지 마”라고 강제할 수 없음

게다가 멀티코어 환경에서는

이미 실행 중인 쓰레드가

GC Thread와 동시에 힙을 수정할 수도 있음

즉,

스케줄링 차원의 ‘실행 안 함’ ≠ 메모리 상태의 ‘안정’

GC는 논리적으로 완전히 멈췄다는 보장이 필요합니다.